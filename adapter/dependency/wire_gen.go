// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package dependency

import (
	"context"

	"go-hexagonal/adapter/repository"
	"go-hexagonal/adapter/repository/mysql/entity"
	"go-hexagonal/config"
	"go-hexagonal/domain/event"
	"go-hexagonal/domain/repo"
	"go-hexagonal/domain/service"
)

// ServiceOption defines an option for service initialization
type ServiceOption func(*service.Services, event.EventBus)

// WithExampleService returns an option to initialize the Example service
func WithExampleService() ServiceOption {
	return func(s *service.Services, eventBus event.EventBus) {
		if s.ExampleService == nil {
			exampleRepo := entity.NewExample()
			s.ExampleService = provideExampleService(exampleRepo, eventBus)
		}
	}
}

// InitializeServices initializes services based on the provided options
func InitializeServices(ctx context.Context, opts ...ServiceOption) (*service.Services, error) {
	// Initialize services container
	eventBus := provideEventBus()
	services := &service.Services{
		EventBus: eventBus,
	}

	// Apply service options
	for _, opt := range opts {
		opt(services, eventBus)
	}

	return services, nil
}

// RepositoryOption defines an option for repository initialization
type RepositoryOption func(*repository.ClientContainer)

// WithMySQL returns an option to initialize MySQL
func WithMySQL() RepositoryOption {
	return func(c *repository.ClientContainer) {
		if c.MySQL == nil {
			mysql, err := ProvideMySQL()
			if err != nil {
				panic("Failed to initialize MySQL: " + err.Error())
			}
			c.MySQL = mysql
		}
	}
}

// WithRedis returns an option to initialize Redis
func WithRedis() RepositoryOption {
	return func(c *repository.ClientContainer) {
		if c.Redis == nil {
			redis, err := ProvideRedis()
			if err != nil {
				panic("Failed to initialize Redis: " + err.Error())
			}
			c.Redis = redis
		}
	}
}

// InitializeRepositories initializes repository clients with the given options
func InitializeRepositories(opts ...RepositoryOption) (*repository.ClientContainer, error) {
	container := &repository.ClientContainer{}
	for _, opt := range opts {
		opt(container)
	}
	return container, nil
}

// ProvideMySQL creates and initializes a MySQL client
func ProvideMySQL() (*repository.MySQL, error) {
	if config.GlobalConfig.MySQL == nil {
		return nil, repository.ErrMissingMySQLConfig
	}

	db, err := repository.OpenGormDB()
	if err != nil {
		return nil, err
	}

	return &repository.MySQL{DB: db}, nil
}

// ProvideRedis creates and initializes a Redis client
func ProvideRedis() (*repository.Redis, error) {
	if config.GlobalConfig.Redis == nil {
		return nil, repository.ErrMissingRedisConfig
	}

	client := repository.NewRedisConn()
	return &repository.Redis{DB: client}, nil
}

// wire.go:

// provideEventBus creates and configures the event bus
func provideEventBus() *event.InMemoryEventBus {
	eventBus := event.NewInMemoryEventBus()

	loggingHandler := event.NewLoggingEventHandler()
	exampleHandler := event.NewExampleEventHandler()
	eventBus.Subscribe(loggingHandler)
	eventBus.Subscribe(exampleHandler)

	return eventBus
}

// provideExampleService creates and configures the example service
func provideExampleService(repo2 repo.IExampleRepo, eventBus event.EventBus) *service.ExampleService {
	// Temporarily use nil instead of cache repository, can implement real cache in the future
	var cacheRepo repo.IExampleCacheRepo = nil
	exampleService := service.NewExampleService(repo2, cacheRepo)
	exampleService.EventBus = eventBus
	return exampleService
}

// Deprecated: Use the new InitializeServices with options pattern instead
func provideServices(exampleService *service.ExampleService, eventBus event.EventBus) *service.Services {
	return service.NewServices(exampleService, eventBus)
}
